#include "myfield.h"
#include <QtGlobal>
MyField::MyField (QObject* parent)
  : QObject(parent)
{
}

void MyField::turn(int whereToMove, Figure wichTurn, bool human, bool rnd)
{
  Stage st = state();  // checking victory or draw
  if (st != Stage::NEXT)
    {
      log_x_.gameOver(st);
      log_0_.gameOver(st);
      emit gameFinished(st);
      return;
    }

  if (whereToMove == 0) // 0 means it's comp turn
    {
    if (rnd)
    whereToMove = wichTurn == Figure::Cross ? rndTurn() : aiTurn(wichTurn);
    else whereToMove = aiTurn(wichTurn);
    }

  if (wichTurn == Figure::Cross) //logging
    log_x_.input(field_, whereToMove);
  else
    log_0_.input(field_, whereToMove);

  if (field_[whereToMove] == 0)  //making turn (writing array)
    field_[whereToMove] = wichTurn;
  else return; //can't make this turn

  if (human)
    emit drawIt(whereToMove, wichTurn); // turn done, signaling to draw

  if ((wichTurn == Figure::Cross) || !human)
    turn(0, wichTurn == Figure::Cross ? wichTurn = Figure::Zero : wichTurn = Figure::Cross, human, rnd); //recursive call of turn with wichTurn inverted;

}

int MyField::rndTurn()
{
  int rnd;
  do {
      rnd = qrand() % 9 + 1;
    }
  while (field_[rnd] != 0);
  return rnd;
}

int MyField::aiTurn(Figure f)
{
  int turn = 0;
  do
    {
      //if turn is impossible tell AI
  turn = (f == Figure::Cross) ? log_x_.askAi(field_, turn) : log_0_.askAi(field_, turn);
    }
  while (field_[turn] != 0);
  return turn;
}


void MyField::reset()
{
  for (int i = 1; i<10; ++i)
    field_[i] = 0;
}

inline Stage MyField::state()
{
  static int solutions [8][3] {{1,2,3},
                        {4,5,6},
                        {7,8,9},
                        {1,4,7},
                        {2,5,8},
                        {3,6,9},
                        {1,5,9},
                        {3,5,7}
                       };
  for (auto f : {Figure::Cross, Figure::Zero})
    for (int x = 0; x < 8; ++x)
      if (field_[solutions[x][0]] == f && field_[solutions[x][1]] == f && field_[solutions[x][2]] == f)
        return f == Figure::Cross ? Stage::WINX : Stage::WIN0;

  bool freePlace;
  for (int i = 1; i < 10; ++i)
    if (field_[i] == 0)
      freePlace = true;
  if (!freePlace)
    return Stage::DRAW;

  return Stage::NEXT;
}

void MyField::display()
{
  log_x_.dataOut();
  log_0_.dataOut();
}



